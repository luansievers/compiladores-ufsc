options {
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(langX)
package parser;

import java.io.*;
import recovery.*;

public class langX {

    final static String Version = "X+++ Language Parser - INE5622 2019.1";
    //contador de erros sintáticos
    int contParseError = 0;
    // controla verbose de recuperação de erros
    boolean debug_recovery;
    Token lastError = null;

    public static void main(String args[]) throws ParseException {
        boolean debug_as = false;
        boolean debug_recovery = false;
        //nome do arquivo a ser analisado
        String filename = "";
        // analisador léxico/sintático
        langX parser;
        int i;
        boolean ms = false;
        int i;
        langX parser; // analisador léxico/sintático
        String filename = ""; // nome do arquivo a ser analisado

        System.out.println(Version);
        // lê os parâmetros passados para o compilador
        for (i = 0; i < args.length - 1; i++) {
            if (args[i].toLowerCase().equals("-debug_AS")) {
                debug_as = true;
            } else if (args[i].toLowerCase().equals("-debug_recovery")) {
                debug_recovery = true;
            } else {
                System.out.println("O uso é: java langX [-debug_AS] [-debug_recovery] nomeDoArquivo");
                System.exit(0);
            }
        }

        if (args[i].equals("-")) { // lê da entrada padrão
            System.out.println("Lendo entrada padrão . . .");
            parser = new langX(System.in); // cria AS
        } else { // lê do arquivo
            filename = args[args.length - 1];
            System.out.println("Lendo do arquivo " + filename + " . . .");
            try { // cria AS
                parser = new langX(new java.io.FileInputStream(filename));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("Arquivo " + filename + " não encontrado.");
                return;
            }
        }

        parser.debug_recovery = debug_recovery;

        if (!debug) {
            //desabilita verbose do AS
            parser.disable_tracing();
        }

        try {
            //ativa a analise
            parser.program();
        } catch (ParseEOFException e) {
            System.out.println(e.getMessage());
        } finally {
            System.out.println(parser.token_source.foundLexError() + " Erros léxicos encontrados");
            System.out.println(parser.contParseError + " Erros sintáticos encontrados");
         }
    }

    //método auxiliar
    static public String im(int x) {
        int k;
        String s;
        s = tokenImage[x];
        k = s.lastIndexOf("\"");
        try {
            s = s.substring(1, k);
        } catch (StringIndexOutOfBoundsException e) {
            //TODO: handle exception
        }
        return s;
    }

    //variável que indfica se EOF foi alcançado
    boolean eof;

    // consome tokens até alcançar um que pertença ao conjunto de sincronização
    void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException {
        Token tok;

        if (debug_recovery) {
            // informação sobre recuperação
            System.out.println();
            System.out.println("*** " + met + " ***");
            System.out.println("     Sincronizando Set: " + g);
        }

        if (g == null) {
            // se o conjunto é null, propaga a exceção
            throw e;
        }

        // pega token corrente
        tok = getToken(1);

        // se não chegou ao fim do arquivo
        while (!eof) {
            //achou um token no conjunto
            if (g.contains(tok.kind)) {
                if (debug_recovery){
                    System.out.println("     Encontrado token sincronizando: " + im(tok.kind));
                }
                break;
            }
            if (debug_recovery) {
                System.out.println("     Ignorando token: " + im(tok.kind));
            }
            // pega próximo token
            getNextToken();
            tok = getToken(1);

            // fim da entrada
            if (tok.kind == EOF && !g.contains(EOF)){
                eof = true;
            }
            if (tok != lastError) {
                System.out.println(e.getMessage());
                lastError = tok;
                // incrementa número de erros
                contParseError++;
            }
            if (eof) {
                throw new ParseEOFException("EOF encontrado prematuramente.")
            }
        }
    }

}
PARSER_END(langX)

TOKEN_MGR_DECLS : {
    int countLexError = 0;
    public int foundLexError() {
        return countLexError;
    }
}

/* Espaços a serem desprezados no início de cada token */
SKIP : {
    " " |
    "\t" |
    "\n" |
    "\r" |
    "\f"
}

SKIP : {
    "/*" : multilinecomment
}

SKIP : {
    "//" : singlelinecomment
}

<multilinecomment> SKIP: {
    "*/" : DEFAULT
    |
    <~[]>
}

<singlelinecomment> SKIP: {
    <["\n","\r"]> : DEFAULT
    |
    <~[]>
}

/* Palavras reservadas */
TOKEN : {
    < BREAK: "break" >
    |
    < CLASS: "class" >
    |
    < CONSTRUCTOR: "constructor" >
    |
    < ELSE: "else" >
    |
    < EXTENDS: "extends" >
    |
    < FOR: "for" >
    |
    < IF: "if" >
    |
    < INT: "int" >
    |
    < NEW: "new" >
    |
    < PRINT: "print" >
    |
    < READ: "read" >
    |
    < RETURN: "return" >
    |
    < STRING: "string" >
    |
    < SUPER: "super" >
    |

    // Qualificadores de identificadores
    < FINAL: "final" >
    |
    < PUBLIC: "public" >
    |
    < PRIVATE: "private" >
    |
    < PROTECTED: "protected" >
    |

    // Novos tipos de variáveis e literais
    < BYTE: "byte" >
    |
    < SHORT: "short" >
    |
    < LONG: "long" >
    |
    < FLOAT: "float" >
}

/* constantes */
TOKEN :
{
    // números decimais, octais, hexadecimais ou binários
    < int_constant:(
        (["0"-"9"] (["0"-"9"])* )
    ) >
    |
    // constante string como "abcd bcda"
    < string_constant:
        "\""( ~["\"","\n","\r"])* "\""
    >
    |
    // constante null
    < null_constant: "null" >
    |
    < byte_constant: ("-")? (<DIGIT> (<DIGIT>)? | ( ["1"]["0"-"1"] ["0"-"9"]) (["1"] ["0"-"2"] ["0"-"7"])) >
    |
    < short_constant: ("-")? ((<DIGIT> (<DIGIT>)? (<DIGIT>)? (<DIGIT>)?) |
                            (["1"-"2"] <DIGIT> <DIGIT> <DIGIT> <DIGIT>) |
                            (["3"] ["0"-"1"] <DIGIT> <DIGIT> <DIGIT>) |
                            (["3"] ["2"] ["0"-"6"] <DIGIT> <DIGIT>) |
                            (["3"] ["2"] ["7"] ["0"-"5"] <DIGIT>) |
                            (["3"] ["2"] ["7"] ["6"] ["0"-"7"])
    ) >
    |
    < long_constant: <DIGIT> (<DIGIT>)* ("l" | "L") >
    |
    < float_constant: (
        <int_constant> "."( <int_constant> ( ("e" | "E")? ("-")? <int_constant> )? )?
        |
        (<int_constant>)? "." <int_constant> (("e" | "E")? ("-")? <int_constant>)? ) ("F" | "f")?
    >

}

/* Identificadores */
TOKEN : {
    < IDENT: <LETTER> (<LETTER>|<DIGIT>)* >
    |
    < #LETTER:["A"-"Z","a"-"z"] >
    |
    < #DIGIT:["0"-"9"] >
}

/* Símbolos especiais */
TOKEN : {
    < LPAREN: "(" >
    |
    < RPAREN: ")" >
    |
    < LBRACE: "{" >
    |
    < RBRACE: "}" >
    |
    < LBRACKET: "[" >
    |
    < RBRACKET: "]" >
    |
    < SEMICOLON: ";" >
    |
    < COMMA: "," >
    |
    < DOT: "." >
}

/* Operadores */
TOKEN : {
    < ASSIGN: "=" >
    |
    < GT: ">" >
    |
    < LT: "<" >
    |
    < EQ: "==" >
    |
    < LE: "<=" >
    |
    < GE: ">=" >
    |
    < NEQ: "!=" >
    |
    < PLUS: "+" >
    |
    < MINUS: "-" >
    |
    < STAR: "*" >
    |
    < SLASH: "/" >
    |
    < REM: "%" >
    |
    // Operadores lógicos
    < AND: "&&" >
    |
    < OR: "||" >
    |
    < XOR: "^" >
    |
    < NOT: "!" >
}

/* Trata os erros léxicos */
SPECIAL_TOKEN : {
    <INVALID_LEXICAL:
        (~ ["a"-"z", "A"-"Z",
        "0"-"9",
        "\"",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        ";",
        ",",
        ".",
        "=",
        ">",
        "<",
        "!",
        "+",
        "-",
        "*",
        "/",
        " ",
        "\t",
        "\n",
        "\r",
        "\f",
        //mudancas
        ":",
        "_",
        "'",
        "|",
        "&",
        "^"
    ])+>
    {
        System.err.println("Linha " + input_stream.getEndLine() +
                           " - string inválida encontrada: " + image);
        countLexError++;
    }
    |
    <INVALID_CONST: "\"" (~ ["\n","\r","\""])* ["\n","\r"]>
    {
        System.err.println("Linha " + input_stream.getEndLine() +
                           " - constante String têm \\n: " + image);
        countLexError++;
    }

}

void program() throws ParseEOFException:
{
    RecoverySet g = First.program;
}{
    <EOF>
    |
    classlist(g)
    try {
        <EOF>
    } catch (ParseException e) {
        consumeUntil(g, e, "program")
    }
    [ program() ]
}

void classlist(RecoverySet g) throws ParseEOFException:
{
    RecoverySet g = First.classlist.union(g);
}{
    classdecl(f) [ LOOKAHEAD(2) classlist(g) ]
}

void classdecl(RecoverySet g) throws ParseEOFException:
{}{
    try {
        [<PUBLIC> | <PRIVATE> | <PROTECTED>] <CLASS>  <IDENT> [ <EXTENDS> <IDENT> ] classbody(g)
    } catch (ParseException e) {
        consumeUntil(g, e, "classdecl")
    }
}

void classbody(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f2 = new RecoverySet(SEMICOLON).union(g).remove(IDENT),
                f3 = First.methoddecl.union(g).remove(IDENT),
                f4 = First.constructdecl.union(f3).remove(IDENT),
                f5 = First.vardecl.union(f4).remove(IDENT);
}{
    try {
        <LBRACE>
           [LOOKAHEAD(2) classlist(f5)]
           (LOOKAHEAD(3) vardecl(f2) <SEMICOLON>)*
           (LOOKAHEAD(2) atribstat(f2) <SEMICOLON>)*
           (LOOKAHEAD(2) constructdecl(f4))*
           (methoddecl(f3))*
        <RBRACE>
    } catch (ParseException e) {
        consumeUntil(g, e, "classbody")
    }
}

void vardecl(RecoverySet g) throws ParseEOFException:
{
	RecoverySet f1 = new RecoverySet(IDENT).union(g);
}{
    try {
        [<PUBLIC> | <PRIVATE> | <PROTECTED>]
        [<FINAL>]
        (primitivetype(f1) | <IDENT> )
        <IDENT> ( <LBRACKET> <RBRACKET>)*
        (<COMMA> <IDENT> ( <LBRACKET> <RBRACKET>)* )*
    } catch (ParseException e) {
        consumeUntil(g, e, "vardecl")
    }
}

void constructdecl(RecoverySet g) throws ParseEOFException:
{}{
    [<PUBLIC> | <PRIVATE> | <PROTECTED>]
    <CONSTRUCTOR> methodbody(g)
}

void methoddecl(RecoverySet g) throws ParseEOFException:
{
	RecoverySet f1 = new RecoverySet(LBRACKET).union(g);
	RecoverySet f2 = new RecoverySet(IDENT).union(f1);
}{
    [<PUBLIC> | <PRIVATE> | <PROTECTED>]
	[<FINAL>]
    (primitivetype(f2) | <IDENT> ) (<LBRACKET> <RBRACKET>)*
    <IDENT> methodbody(g)
}

void methodbody(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f = new RecoverySet(RPAREN).union(g);
}{
    try {
        <LPAREN> paramlist(f) <RPAREN> statement(g)
    } catch (ParseException e) {
        consumeUntil(g, e, "methodbody")
    }
}

void paramlist(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(IDENT).union(g);
}{
    try {
        [
         (primitivetype(f1) | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)*
         (<COMMA> (primitivetype(f1) | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)* )*
        ]
    } catch (ParseException e) {
        consumeUntil(g, e, "paramlist")
    }
}

void statement(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(SEMICOLON).union(g).remove(IDENT);
    RecoverySet f2 = new RecoverySet(RBRACE).union(g).remove(IDENT);
}{
    try {
        LOOKAHEAD(3)
        methodcall(f1) <SEMICOLON>
    |
        LOOKAHEAD(<IDENT> <IDENT>)
        vardecl(f1) <SEMICOLON>
    |
        LOOKAHEAD(1)
        atribstat(f1) <SEMICOLON>
    |
        vardecl(f1) <SEMICOLON>
    |
        printstat(f1) <SEMICOLON>
    |
        readstat(f1) <SEMICOLON>
    |
        returnstat(f1) <SEMICOLON>
    |
        superstat(f1) <SEMICOLON>
    |
        ifstat(g)
    |
        forstat(g)
    |
        <LBRACE> statlist(f2) <RBRACE>
    |
        <BREAK> <SEMICOLON>
    |
        <SEMICOLON>
    } catch (ParseException e) {
        consumeUntil(g, e, "statement")
    }
}

void methodcall(RecoverySet g) throws ParseEOFException:
{
	RecoverySet f1 = new RecoverySet(RPAREN).union(g);
}{
    try {
        <IDENT> (<DOT> <IDENT>)* <LPAREN> paramlist(f1) <RPAREN>
    } catch (ParseException e) {
        consumeUntil(g, e, "methodcall")
    }
}

void atribstat(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(ASSIGN).union(g);
}
{
    try {
        lvalue(f1) <ASSIGN> ( alocexpression(g) | LOOKAHEAD(3) logicexpression(g) | LOOKAHEAD(3) methodcall(g))
} catch (ParseException e) {
        consumeUntil(g, e, "atribstat")
    }
}

void printstat(RecoverySet g) throws ParseEOFException:
{}{
    try {
        <PRINT> logicexpression(g)
    } catch (ParseException e) {
        consumeUntil(g, e, "printstat")
    }
}

void readstat(RecoverySet g) throws ParseEOFException:
{}{
    try {
        <READ> lvalue(g)
    } catch (ParseException e) {
        consumeUntil(g, e, "readstat")
    }
}

void returnstat(RecoverySet g) throws ParseEOFException:
{}{
    try {
        <RETURN> [logicexpression(g)]
    } catch (ParseException e) {
        consumeUntil(g, e, "returnstat")
    }
}

void superstat(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f = new RecoverySet(RPAREN).union(g);
}{
    try {
        <SUPER> <LPAREN> arglist(f) <RPAREN>
    } catch (ParseException e) {
        consumeUntil(g, e, "superstat")
    }
}

void ifstat(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(RPAREN).union(g),
                f2 = new RecoverySet(ELSE).union(g);
}{
    try {
        <IF> <LPAREN> expression(f1) <RPAREN> statement(f2)
        [LOOKAHEAD(1) <ELSE> statement(g)]
    } catch (ParseException e) {
        consumeUntil(g, e, "ifstat")
    }
}

void forstat(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(SEMICOLON).union(g),
                f2 = new RecoverySet(RPAREN).union(g);
}{
    try {
        <FOR> <LPAREN>  [atribstat(f1)] <SEMICOLON>
                        [logicexpression(f1)] <SEMICOLON>
                        [atribstat(f2)] <RPAREN>
                        statement(g)
    } catch (ParseException e) {
        consumeUntil(g, e, "forstat")
    }
}

void statlist(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f = First.statlist.remove(IDENT).union(g);
}{
    statement(f) [statlist(g)]
}

void lvalue(RecoverySet g) throws ParseEOFException:
{}{
    try {
        <IDENT> (
            <LBRACKET> expression(null) <RBRACKET> |
            <DOT> <IDENT> [<LPAREN> arglist(null) <RPAREN>]
            )*
    } catch (ParseException e) {
        consumeUntil(g, e, "lvalue")
    }
}

void alocexpression(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f1 = new RecoverySet(RPAREN).union(g),
                f2 = new RecoverySet(RBRACKET).union(g),
                f3 = new RecoverySet(LBRACKET).union(g);
}{
    <NEW> (
        LOOKAHEAD(2) <IDENT> <LPAREN> arglist(f1) <RPAREN> |
        ( primitivetype(f3) | <IDENT> )
        (<LBRACKET> expression(f2) <RBRACKET>)+
        )
}


void logicexpression(RecoverySet g) throws ParseEOFException:
{
	RecoverySet f1 = new RecoverySet(XOR).union(g);
	RecoverySet f2 = new RecoverySet(OR).union(f1);
	RecoverySet f3 = new RecoverySet(AND).union(f2);
}{
    try {
        [<NOT>] expression(f3) (( <XOR> | <OR> | <AND>) [<NOT>] expression(f3))*
      } catch (ParseException e) {
        consumeUntil(g, e, "logicexpression")
    }
}

void expression(RecoverySet g) throws ParseEOFException:
{}{
    try {
        numexpr() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ>) numexpr()]
    } catch (ParseException e) {
        consumeUntil(g, e, "expression")
    }
}

void numexpr() throws ParseEOFException:
{}{
    term() ((<PLUS> | <MINUS>) term())*
}

void term() throws ParseEOFException:
{}{
    unaryexpr() ((<STAR> | <SLASH>| <REM>) unaryexpr())*
}

void unaryexpr() throws ParseEOFException:
{}{
    [(<PLUS> | <MINUS>)] factor()
}


void factor() throws ParseEOFException:
{}{
    (
        <int_constant> |
        <string_constant> |
        <byte_constant> |
        <short_constant> |
        <long_constant> |
        <float_constant> |
        <null_constant> |
        LOOKAHEAD(3) lvalue(null) |
        methodcall(null) |
        <LPAREN> expression(null) <RPAREN>
    )
}

void arglist(RecoverySet g) throws ParseEOFException:
{
    RecoverySet f = new RecoverySet(COMMA).union(g);
}{
    [logicexpression(f) (<COMMA> logicexpression(f))*]
}

void primitivetype(RecoverySet g) throws ParseEOFException:
{}{
	(<INT> | <STRING> | <BYTE> | <SHORT> | <LONG> | <FLOAT>)
}
