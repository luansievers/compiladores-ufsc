options {
    STATIC = false;
}

PARSER_BEGIN(langX)
package parser;

import java.io.*;

public class langX {

    final static String Version = "X+++ Language Parser - INE5622 2019.1";
    boolean Menosshort = false; //saída resumida

    public static void main(String args[]) throws ParseException {
        String filename = ""; //nome do arquivo a ser analisado
        langX parser;
        int i;
        boolean ms = false;

        System.out.println(Version);

        //lê os params passados
        for (i = 0; i < args.length - 1; i++) {
            if (args[i].toLowerCase().equals("-short")) {
                ms = true;
            } else {
                System.out.println("O uso é: java langX [-short] nomeDoArquivo");
                System.exit(0);
            }
        }

        if (args[i].equals("-")) {
            //lê a entrada padrão
            System.out.println("Lendo entrada padrão . . .");
            parser = new langX(System.in);
        } else {
            //lê o arquivo
            filename = args[args.length - 1];
            System.out.println("Lendo do arquivo " + filename + " . . .");
            try {
                parser = new langX(new java.io.FileInputStream(filename));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("Arquivo " + filename + " não encontrado.");
                return;
            }
        }

        parser.Menosshort = ms;
        parser.program(); //ativa a analise

        //verifica se houve erro
        if (parser.token_source.foundLexError() != 0) {
            System.out.println(parser.token_source.foundLexError() + " Erros léxicos encontrados");
        } else {
            System.out.println("Programa analisado com sucesso.");
        }
    }

    static public String im(int x) { //método auxiliar
        int k;
        String s;
        s = tokenImage[x];
        k = s.lastIndexOf("\"");
        try {
            s = s.substring(1, k);
        } catch (StringIndexOutOfBoundsException e) {
        }
        return s;
    }

}
PARSER_END(langX)

TOKEN_MGR_DECLS : {
    int countLexError = 0;
    public int foundLexError() {
        return countLexError;
    }
}

/* Espaços a serem desprezados no início de cada token */
SKIP : {
    " " |
    "\t" |
    "\n" |
    "\r" |
    "\f"
}

SKIP : {
    "/*" : multilinecomment
}

SKIP : {
    "//" : singlelinecomment
}

<multilinecomment> SKIP: {
    "*/" : DEFAULT | <~[]>
}

<singlelinecomment> SKIP: {
    <["\n","\r"]> : DEFAULT | <~[]>
}

/* Palavras reservadas */
TOKEN : {
    < BREAK: "break" > |
    < CLASS: "class" > |
    < CONSTRUCTOR: "constructor" > |
    < ELSE: "else" > |
    < EXTENDS: "extends" > |
    < FOR: "for" > |
    < IF: "if" > |
    < INT: "int" > |
    < NEW: "new" > |
    < PRINT: "print" > |
    < READ: "read" > |
    < RETURN: "return" > |
    < STRING: "string" > |
    < SUPER: "super" > |

    // Qualificadores de identificadores
    < FINAL: "final" > |
    < PUBLIC: "public" > |
    < PRIVATE: "private" > |
    < PROTECTED: "protected" > |

    // Novos tipos de variáveis e literais
    < BYTE: "byte" > |
    < SHORT: "short" > |
    < LONG: "long" > |
    < FLOAT: "float" >
}

/* constantes */
TOKEN : {
    < int_constant:(  // números decimais
                  (["0"-"9"] (["0"-"9"])* )) >
    |

    < string_constant:    // constante string como "abcd bcda"
      "\""( ~["\"","\n","\r"])* "\"" >
    |

    < null_constant: "null" > // constante null
    |

    < byte_constant: ("-")? (<DIGIT> (<DIGIT>)? | ( ["1"]["0"-"1"] ["0"-"9"]) (["1"] ["0"-"2"] ["0"-"7"])) >
    |

    < short_constant: ("-")? ((<DIGIT> (<DIGIT>)? (<DIGIT>)? (<DIGIT>)?) |
                            (["1"-"2"] <DIGIT> <DIGIT> <DIGIT> <DIGIT>) |
                            (["3"] ["0"-"1"] <DIGIT> <DIGIT> <DIGIT>) |
                            (["3"] ["2"] ["0"-"6"] <DIGIT> <DIGIT>) |
                            (["3"] ["2"] ["7"] ["0"-"5"] <DIGIT>) |
                            (["3"] ["2"] ["7"] ["6"] ["0"-"7"])) >
    |

    < long_constant: <DIGIT> (<DIGIT>)* ("l" | "L") >
    |

    < float_constant: (<int_constant> "." ( <int_constant> ( ("e" | "E")? ("-")? <int_constant> )? )? | (<int_constant>)? "." <int_constant> (("e" | "E")? ("-")? <int_constant>)? ) ("F" | "f")? >

}

/* Identificadores */
TOKEN : {
    < IDENT: <LETTER> (<LETTER>|<DIGIT>)* > |
    < #LETTER:["A"-"Z","a"-"z"] > |
    < #DIGIT:["0"-"9"] >
}

/* Símbolos especiais */
TOKEN : {
    < LPAREN: "(" > |
    < RPAREN: ")" > |
    < LBRACE: "{" > |
    < RBRACE: "}" > |
    < LBRACKET: "[" > |
    < RBRACKET: "]" > |
    < SEMICOLON: ";" > |
    < COMMA: "," > |
    < DOT: "." >
}

/* Operadores */
TOKEN : {
    < ASSIGN: "=" > |
    < GT: ">" > |
    < LT: "<" > |
    < EQ: "==" > |
    < LE: "<=" > |
    < GE: ">=" > |
    < NEQ: "!=" > |
    < PLUS: "+" > |
    < MINUS: "-" > |
    < STAR: "*" > |
    < SLASH: "/" > |
    < REM: "%" > |

    // Operadores lógicos
    < AND: "&&" > |
    < OR: "||" > |
    < XOR: "^" > |
    < NOT: "!" >
}

/* Trata os erros léxicos */
SPECIAL_TOKEN : {
    <INVALID_LEXICAL:
    (~ ["a"-"z", "A"-"Z",
    "0"-"9",
    "\"",
    "(",
    ")",
    "[",
    "]",
    "{",
    "}",
    ";",
    ",",
    ".",
    "=",
    ">",
    "<",
    "!",
    "+",
    "-",
    "*",
    "/",
    "%",
    " ",
    "\t",
    "\n",
    "\r",
    "\f"
    ])+>
    {
        System.err.println("Linha " + input_stream.getEndLine() +
                           " - string inválida encontrada: " + image);
        countLexError++;
    } |
    <INVALID_CONST: "\"" (~ ["\n","\r","\""])* ["\n","\r"]>
    {
        System.err.println("Linha " + input_stream.getEndLine() +
                           " - constante String têm \\n: " + image);
        countLexError++;
    }

}

JAVACODE void program() {
    Token t;
    do {
        t = getNextToken();
        Token st = t;
        while (st.specialToken != null) {
            st = st.specialToken;
        }
        do {
            if (Menosshort) {
                System.out.println(st.image + "  " + im(st.kind) + " " + st.kind);
            } else {
                System.out.println("Linha: " + st.beginLine + " Coluna: " + st.beginColumn + " "
                        + st.image + "  " + im(st.kind) + "  " + t.kind);
                st = st.next;
            }
        } while (st != t.next);
    } while (t.kind != langXConstants.EOF);
}
